module 0x46566b4a16a1261ab400ab5b9067de84ba152b5eb4016b217187f2a2ca980c5a::tick_math {
    use 0x46566b4a16a1261ab400ab5b9067de84ba152b5eb4016b217187f2a2ca980c5a::bit_math;
    use 0x46566b4a16a1261ab400ab5b9067de84ba152b5eb4016b217187f2a2ca980c5a::fixed_point;
    use 0x46566b4a16a1261ab400ab5b9067de84ba152b5eb4016b217187f2a2ca980c5a::tick;
    public fun get_sqrt_price_at_tick(p0: u32): u128 {
        let _v0;
        let _v1;
        let _v2 = tick::max_tick();
        assert!(p0 <= _v2, 1);
        let _v3 = tick::zero_tick();
        if (p0 < _v3) _v1 = tick::zero_tick() - p0 else {
            let _v4 = tick::zero_tick();
            _v1 = p0 - _v4
        };
        let _v5 = _v1;
        if (_v5 & 1u32 != 0u32) _v0 = 340265354078544976698082559843614326784u256 else _v0 = 340282366920938463463374607431768211456u256;
        let _v6 = _v0;
        if (_v5 & 2u32 != 0u32) _v6 = _v6 * 340248342086729784833163084424934326272u256 >> 128u8;
        if (_v5 & 4u32 != 0u32) _v6 = _v6 * 340214320654664318389990405825464631296u256 >> 128u8;
        if (_v5 & 8u32 != 0u32) _v6 = _v6 * 340146287995602338275853453755324301312u256 >> 128u8;
        if (_v5 & 16u32 != 0u32) _v6 = _v6 * 340010263488231178223853832463785656320u256 >> 128u8;
        if (_v5 & 32u32 != 0u32) _v6 = _v6 * 339738377640345476870261989487337799680u256 >> 128u8;
        if (_v5 & 64u32 != 0u32) _v6 = _v6 * 339195258003219658561184762853115035648u256 >> 128u8;
        if (_v5 & 128u32 != 0u32) _v6 = _v6 * 338111622100602086564262494681729859584u256 >> 128u8;
        if (_v5 & 256u32 != 0u32) _v6 = _v6 * 335954724994790710924045888443083915264u256 >> 128u8;
        if (_v5 & 512u32 != 0u32) _v6 = _v6 * 331682121138380177001083646313987309568u256 >> 128u8;
        if (_v5 & 1024u32 != 0u32) _v6 = _v6 * 323299236684854836574038915838422024192u256 >> 128u8;
        if (_v5 & 2048u32 != 0u32) _v6 = _v6 * 307163716377036449298628741423763030016u256 >> 128u8;
        if (_v5 & 4096u32 != 0u32) _v6 = _v6 * 277268403626902478617217471084343853056u256 >> 128u8;
        if (_v5 & 8192u32 != 0u32) _v6 = _v6 * 225923453940452822857498961015547625472u256 >> 128u8;
        if (_v5 & 16384u32 != 0u32) _v6 = _v6 * 149997214084980533347406722303197708288u256 >> 128u8;
        if (_v5 & 32768u32 != 0u32) _v6 = _v6 * 66119101136036705030569676839239811072u256 >> 128u8;
        if (_v5 & 65536u32 != 0u32) _v6 = _v6 * 12847376061813933090541833434062389248u256 >> 128u8;
        if (_v5 & 131072u32 != 0u32) _v6 = _v6 * 485053260817416266108873772866994176u256 >> 128u8;
        if (_v5 & 262144u32 != 0u32) _v6 = _v6 * 691415978907519520719790451720192u256 >> 128u8;
        let _v7 = tick::zero_tick();
        if (p0 > _v7) _v6 = 115792089237316195423570985008687907853269984665640564039457584007913129639935u256 / _v6;
        (_v6 >> 48u8) as u128
    }
    public fun get_tick_at_sqrt_price(p0: u128): u32 {
        let _v0;
        let _v1;
        let _v2;
        let _v3;
        let _v4;
        if (p0 >= 281480266797392u128) _v1 = p0 <= 5192199275492655220258463701383891u128 else _v1 = false;
        assert!(_v1, 2);
        let _v5 = p0;
        let _v6 = bit_math::most_significant_bit_u128(_v5);
        let _v7 = _v6 >= 80u8;
        if (_v7) {
            let _v8 = _v6 - 79u8;
            _v2 = (_v5 >> _v8) as u256;
            _v3 = (_v6 - 80u8) as u128
        } else {
            let _v9 = 79u8 - _v6;
            _v2 = (_v5 << _v9) as u256;
            _v3 = (80u8 - _v6) as u128
        };
        _v3 = _v3 << 16u8;
        let _v10 = 0u128;
        let _v11 = 16u8;
        while (_v11 > 0u8) {
            _v2 = _v2 * _v2 >> 79u8;
            let _v12 = (_v2 >> 80u8) as u128;
            let _v13 = _v11 - 1u8;
            let _v14 = _v12 << _v13;
            _v10 = _v10 | _v14;
            let _v15 = _v12 as u8;
            _v2 = _v2 >> _v15;
            _v11 = _v11 - 1u8;
            continue
        };
        if (_v7) _v3 = _v3 + _v10 else _v3 = _v3 - _v10;
        let _v16 = _v3 * 255738959000112587603968u128;
        if (_v7) {
            let _v17 = fixed_point::u128_to_x80_u128(tick::zero_tick() as u128);
            _v16 = _v16 + _v17
        } else {
            let _v18;
            let _v19 = fixed_point::u128_to_x80_u128(tick::zero_tick() as u128);
            let _v20 = _v16;
            let _v21 = _v19;
            if (_v21 > _v20) _v18 = _v21 - _v20 else _v18 = 0u128;
            _v16 = _v18
        };
        let _v22 = 12089258196146291998720u128;
        let _v23 = _v16;
        if (_v23 > _v22) _v0 = _v23 - _v22 else _v0 = 0u128;
        let _v24 = (_v0 >> 80u8) as u32;
        let _v25 = (_v16 + 267828217196258890088448u128 >> 80u8) as u32;
        if (_v24 == _v25) _v4 = _v24 else {
            let _v26;
            if (get_sqrt_price_at_tick(_v25) <= p0) _v26 = _v25 else _v26 = _v24;
            _v4 = _v26
        };
        _v4
    }
    public fun max_sqrt_price(): u128 {
        5192199275492655220258463701383891u128
    }
    public fun min_sqrt_price(): u128 {
        281480266797392u128
    }
}
